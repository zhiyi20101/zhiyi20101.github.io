# 什么是Android 16ms？
所谓的Android 16ms定律，是指的是Android系统每隔16ms刷新屏幕界面，也就是60hz。
  
  这是因为大多数的Android显示屏幕是以每秒60帧来刷新的（也就是60Hz）。一帧可以看做是一张的独立图片，
60帧每秒就意味着:16ms=1000/60Hz，相当于60fps。这就是上面说的16ms，这也是为什么Android系统每隔16ms就会发出一次VSYNC信号触发对UI进行渲染，
如果这16ms内我们没有完成对视图的绘制，那么就会出现丢帧的情况
# 为什么是16ms？
这是因为人眼与大脑之间的协作无法感知超过60fps的画面更新。12fps大概类似手动快速翻动书籍的帧率，这明显是可以感知到不够顺滑的。
24fps使得人眼感知的是连续线性的运动，这其实是归功于运动模糊的 效果。24fps是电影胶圈通常使用的帧率，因为这个帧率已经足够支撑大部分电影画面需要表达的内容，同时能够最大的减少费用支出。
但是低于30fps是 无法顺畅表现绚丽的画面内容的，此时就需要用到60fps来达到想要的效果，当然超过60fps是没有必要的（据说Dart能够带来120fps的体验）
# 如何避免16ms导致的卡顿问题？
1.尽可能减少Overdraw，就是减少过渡绘制，减少布局嵌套的层次，去掉重复设置的背景；

2.减少listview中getView中的耗时操作，一些自定义的view尽可能减少invalidate的调用；

3.尽可能不要在UI线程做过多耗时的操作；
# 卡顿的原因
原因是出现了丢帧现象。为什么会出现丢帧现象？
## 何为丢帧
　　
  由于某些原因，比如我们应用代码上处理不够好，又或者用户手机后台打开了很多应用，又在听歌又在下载视频什么的，CPU一时间被占用了，导致下一帧绘制的时间超过了16ms，那么问题就来了，这时候用户就不爽了，因为用户很明显感知到了卡顿的出现。
## 卡顿产生的原因
  
  Step1. 当Display显示第0帧数据，此时CPU和GPU已经开始渲染第1帧画面，并将数据缓存在缓冲B中；

  Step2. 但是由于某些原因，就好像上面说的，CPU资源一时间被占用，导致系统处理该帧数据耗时过长或者未能及时处理该帧数据；

  Step3. 当VSYNC信号来时，display向B缓冲要数据，这下悲催了，因为缓冲B的数据还没准备好，B缓冲区这时候是被锁定的，display无可奈何，只能继续显示之前缓冲A的那一帧，此时缓冲A的数据也不能被清空和交换数据。这种情况被Android开发组命名为“Jank”，就是所谓的“丢帧”，也被称作“废帧”；

  Step4. 当第1帧数据（即缓冲B数据）准备完成后，它并不会马上被显示，而是要等待下一个VSYNC，Display刷新后，这时用户才看到画面的更新，中间这段时间的时间就白白被浪费掉了。
  
  ![Image text](http://upload-images.jianshu.io/upload_images/1371984-94e8a090b86faa44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
   
   很简单，也就是让红色的小球向上移动了一段距离。但由于你的应用没能在16ms内完成界面更新，导致你的用户盯着第一个屏幕看了32ms，然后发现小球“跳”到了一个新的高度，而不是平滑地移动到了新的高度。

上面所说的情况称作“丢帧”。
　　
  
